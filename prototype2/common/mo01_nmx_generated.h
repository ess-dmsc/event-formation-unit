// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MO01NMX_H_
#define FLATBUFFERS_GENERATED_MO01NMX_H_

#include "flatbuffers/flatbuffers.h"

struct pos;

struct MONHit;

struct GEMTrack;

struct GEMHist;

struct MonitorMessage;

enum class DataField : uint8_t {
  NONE = 0,
  GEMHist = 1,
  GEMTrack = 2,
  MONHit = 3,
  MIN = NONE,
  MAX = MONHit
};

inline const char **EnumNamesDataField() {
  static const char *names[] = {"NONE", "GEMHist", "GEMTrack", "MONHit",
                                nullptr};
  return names;
}

inline const char *EnumNameDataField(DataField e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDataField()[index];
}

template <typename T> struct DataFieldTraits {
  static const DataField enum_value = DataField::NONE;
};

template <> struct DataFieldTraits<GEMHist> {
  static const DataField enum_value = DataField::GEMHist;
};

template <> struct DataFieldTraits<GEMTrack> {
  static const DataField enum_value = DataField::GEMTrack;
};

template <> struct DataFieldTraits<MONHit> {
  static const DataField enum_value = DataField::MONHit;
};

bool VerifyDataField(flatbuffers::Verifier &verifier, const void *obj,
                     DataField type);
bool VerifyDataFieldVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types);

struct pos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "pos";
  }
  enum { VT_TIME = 4, VT_STRIP = 6, VT_ADC = 8 };
  uint16_t time() const { return GetField<uint16_t>(VT_TIME, 0); }
  bool mutate_time(uint16_t _time) { return SetField(VT_TIME, _time); }
  uint16_t strip() const { return GetField<uint16_t>(VT_STRIP, 0); }
  bool mutate_strip(uint16_t _strip) { return SetField(VT_STRIP, _strip); }
  uint16_t adc() const { return GetField<uint16_t>(VT_ADC, 0); }
  bool mutate_adc(uint16_t _adc) { return SetField(VT_ADC, _adc); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TIME) &&
           VerifyField<uint16_t>(verifier, VT_STRIP) &&
           VerifyField<uint16_t>(verifier, VT_ADC) && verifier.EndTable();
  }
};

struct posBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(uint16_t time) {
    fbb_.AddElement<uint16_t>(pos::VT_TIME, time, 0);
  }
  void add_strip(uint16_t strip) {
    fbb_.AddElement<uint16_t>(pos::VT_STRIP, strip, 0);
  }
  void add_adc(uint16_t adc) { fbb_.AddElement<uint16_t>(pos::VT_ADC, adc, 0); }
  posBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  posBuilder &operator=(const posBuilder &);
  flatbuffers::Offset<pos> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<pos>(end);
    return o;
  }
};

inline flatbuffers::Offset<pos> Createpos(flatbuffers::FlatBufferBuilder &_fbb,
                                          uint16_t time = 0, uint16_t strip = 0,
                                          uint16_t adc = 0) {
  posBuilder builder_(_fbb);
  builder_.add_adc(adc);
  builder_.add_strip(strip);
  builder_.add_time(time);
  return builder_.Finish();
}

struct MONHit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MONHit";
  }
  enum { VT_PLANE = 4, VT_TIME = 6, VT_CHANNEL = 8, VT_ADC = 10 };
  const flatbuffers::Vector<uint16_t> *plane() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_PLANE);
  }
  flatbuffers::Vector<uint16_t> *mutable_plane() {
    return GetPointer<flatbuffers::Vector<uint16_t> *>(VT_PLANE);
  }
  const flatbuffers::Vector<uint32_t> *time() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_TIME);
  }
  flatbuffers::Vector<uint32_t> *mutable_time() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_TIME);
  }
  const flatbuffers::Vector<uint16_t> *channel() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_CHANNEL);
  }
  flatbuffers::Vector<uint16_t> *mutable_channel() {
    return GetPointer<flatbuffers::Vector<uint16_t> *>(VT_CHANNEL);
  }
  const flatbuffers::Vector<uint16_t> *adc() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_ADC);
  }
  flatbuffers::Vector<uint16_t> *mutable_adc() {
    return GetPointer<flatbuffers::Vector<uint16_t> *>(VT_ADC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PLANE) &&
           verifier.Verify(plane()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TIME) &&
           verifier.Verify(time()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHANNEL) &&
           verifier.Verify(channel()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADC) &&
           verifier.Verify(adc()) && verifier.EndTable();
  }
};

struct MONHitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_plane(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> plane) {
    fbb_.AddOffset(MONHit::VT_PLANE, plane);
  }
  void add_time(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> time) {
    fbb_.AddOffset(MONHit::VT_TIME, time);
  }
  void add_channel(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> channel) {
    fbb_.AddOffset(MONHit::VT_CHANNEL, channel);
  }
  void add_adc(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> adc) {
    fbb_.AddOffset(MONHit::VT_ADC, adc);
  }
  MONHitBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MONHitBuilder &operator=(const MONHitBuilder &);
  flatbuffers::Offset<MONHit> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<MONHit>(end);
    return o;
  }
};

inline flatbuffers::Offset<MONHit>
CreateMONHit(flatbuffers::FlatBufferBuilder &_fbb,
             flatbuffers::Offset<flatbuffers::Vector<uint16_t>> plane = 0,
             flatbuffers::Offset<flatbuffers::Vector<uint32_t>> time = 0,
             flatbuffers::Offset<flatbuffers::Vector<uint16_t>> channel = 0,
             flatbuffers::Offset<flatbuffers::Vector<uint16_t>> adc = 0) {
  MONHitBuilder builder_(_fbb);
  builder_.add_adc(adc);
  builder_.add_channel(channel);
  builder_.add_time(time);
  builder_.add_plane(plane);
  return builder_.Finish();
}

inline flatbuffers::Offset<MONHit>
CreateMONHitDirect(flatbuffers::FlatBufferBuilder &_fbb,
                   const std::vector<uint16_t> *plane = nullptr,
                   const std::vector<uint32_t> *time = nullptr,
                   const std::vector<uint16_t> *channel = nullptr,
                   const std::vector<uint16_t> *adc = nullptr) {
  return CreateMONHit(_fbb, plane ? _fbb.CreateVector<uint16_t>(*plane) : 0,
                      time ? _fbb.CreateVector<uint32_t>(*time) : 0,
                      channel ? _fbb.CreateVector<uint16_t>(*channel) : 0,
                      adc ? _fbb.CreateVector<uint16_t>(*adc) : 0);
}

struct GEMTrack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "GEMTrack";
  }
  enum {
    VT_TIME_OFFSET = 4,
    VT_XTRACK = 6,
    VT_YTRACK = 8,
    VT_XPOS = 10,
    VT_YPOS = 12
  };
  uint64_t time_offset() const { return GetField<uint64_t>(VT_TIME_OFFSET, 0); }
  bool mutate_time_offset(uint64_t _time_offset) {
    return SetField(VT_TIME_OFFSET, _time_offset);
  }
  const flatbuffers::Vector<flatbuffers::Offset<pos>> *xtrack() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pos>> *>(
        VT_XTRACK);
  }
  flatbuffers::Vector<flatbuffers::Offset<pos>> *mutable_xtrack() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<pos>> *>(
        VT_XTRACK);
  }
  const flatbuffers::Vector<flatbuffers::Offset<pos>> *ytrack() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pos>> *>(
        VT_YTRACK);
  }
  flatbuffers::Vector<flatbuffers::Offset<pos>> *mutable_ytrack() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<pos>> *>(
        VT_YTRACK);
  }
  double xpos() const { return GetField<double>(VT_XPOS, 0.0); }
  bool mutate_xpos(double _xpos) { return SetField(VT_XPOS, _xpos); }
  double ypos() const { return GetField<double>(VT_YPOS, 0.0); }
  bool mutate_ypos(double _ypos) { return SetField(VT_YPOS, _ypos); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIME_OFFSET) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_XTRACK) &&
           verifier.Verify(xtrack()) &&
           verifier.VerifyVectorOfTables(xtrack()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_YTRACK) &&
           verifier.Verify(ytrack()) &&
           verifier.VerifyVectorOfTables(ytrack()) &&
           VerifyField<double>(verifier, VT_XPOS) &&
           VerifyField<double>(verifier, VT_YPOS) && verifier.EndTable();
  }
};

struct GEMTrackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_offset(uint64_t time_offset) {
    fbb_.AddElement<uint64_t>(GEMTrack::VT_TIME_OFFSET, time_offset, 0);
  }
  void
  add_xtrack(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pos>>>
                 xtrack) {
    fbb_.AddOffset(GEMTrack::VT_XTRACK, xtrack);
  }
  void
  add_ytrack(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pos>>>
                 ytrack) {
    fbb_.AddOffset(GEMTrack::VT_YTRACK, ytrack);
  }
  void add_xpos(double xpos) {
    fbb_.AddElement<double>(GEMTrack::VT_XPOS, xpos, 0.0);
  }
  void add_ypos(double ypos) {
    fbb_.AddElement<double>(GEMTrack::VT_YPOS, ypos, 0.0);
  }
  GEMTrackBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GEMTrackBuilder &operator=(const GEMTrackBuilder &);
  flatbuffers::Offset<GEMTrack> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<GEMTrack>(end);
    return o;
  }
};

inline flatbuffers::Offset<GEMTrack> CreateGEMTrack(
    flatbuffers::FlatBufferBuilder &_fbb, uint64_t time_offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pos>>> xtrack =
        0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pos>>> ytrack =
        0,
    double xpos = 0.0, double ypos = 0.0) {
  GEMTrackBuilder builder_(_fbb);
  builder_.add_ypos(ypos);
  builder_.add_xpos(xpos);
  builder_.add_time_offset(time_offset);
  builder_.add_ytrack(ytrack);
  builder_.add_xtrack(xtrack);
  return builder_.Finish();
}

inline flatbuffers::Offset<GEMTrack> CreateGEMTrackDirect(
    flatbuffers::FlatBufferBuilder &_fbb, uint64_t time_offset = 0,
    const std::vector<flatbuffers::Offset<pos>> *xtrack = nullptr,
    const std::vector<flatbuffers::Offset<pos>> *ytrack = nullptr,
    double xpos = 0.0, double ypos = 0.0) {
  return CreateGEMTrack(
      _fbb, time_offset,
      xtrack ? _fbb.CreateVector<flatbuffers::Offset<pos>>(*xtrack) : 0,
      ytrack ? _fbb.CreateVector<flatbuffers::Offset<pos>>(*ytrack) : 0, xpos,
      ypos);
}

struct GEMHist FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "GEMHist";
  }
  enum {
    VT_XSTRIPS = 4,
    VT_YSTRIPS = 6,
    VT_XSPECTRUM = 8,
    VT_YSPECTRUM = 10,
    VT_CLUSTER_SPECTRUM = 12,
    VT_BIN_WIDTH = 14
  };
  const flatbuffers::Vector<uint32_t> *xstrips() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_XSTRIPS);
  }
  flatbuffers::Vector<uint32_t> *mutable_xstrips() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_XSTRIPS);
  }
  const flatbuffers::Vector<uint32_t> *ystrips() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_YSTRIPS);
  }
  flatbuffers::Vector<uint32_t> *mutable_ystrips() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_YSTRIPS);
  }
  const flatbuffers::Vector<uint32_t> *xspectrum() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_XSPECTRUM);
  }
  flatbuffers::Vector<uint32_t> *mutable_xspectrum() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_XSPECTRUM);
  }
  const flatbuffers::Vector<uint32_t> *yspectrum() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_YSPECTRUM);
  }
  flatbuffers::Vector<uint32_t> *mutable_yspectrum() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_YSPECTRUM);
  }
  const flatbuffers::Vector<uint32_t> *cluster_spectrum() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(
        VT_CLUSTER_SPECTRUM);
  }
  flatbuffers::Vector<uint32_t> *mutable_cluster_spectrum() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_CLUSTER_SPECTRUM);
  }
  uint32_t bin_width() const { return GetField<uint32_t>(VT_BIN_WIDTH, 0); }
  bool mutate_bin_width(uint32_t _bin_width) {
    return SetField(VT_BIN_WIDTH, _bin_width);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_XSTRIPS) &&
           verifier.Verify(xstrips()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_YSTRIPS) &&
           verifier.Verify(ystrips()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_XSPECTRUM) &&
           verifier.Verify(xspectrum()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_YSPECTRUM) &&
           verifier.Verify(yspectrum()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CLUSTER_SPECTRUM) &&
           verifier.Verify(cluster_spectrum()) &&
           VerifyField<uint32_t>(verifier, VT_BIN_WIDTH) && verifier.EndTable();
  }
};

struct GEMHistBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_xstrips(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> xstrips) {
    fbb_.AddOffset(GEMHist::VT_XSTRIPS, xstrips);
  }
  void add_ystrips(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> ystrips) {
    fbb_.AddOffset(GEMHist::VT_YSTRIPS, ystrips);
  }
  void
  add_xspectrum(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> xspectrum) {
    fbb_.AddOffset(GEMHist::VT_XSPECTRUM, xspectrum);
  }
  void
  add_yspectrum(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> yspectrum) {
    fbb_.AddOffset(GEMHist::VT_YSPECTRUM, yspectrum);
  }
  void add_cluster_spectrum(
      flatbuffers::Offset<flatbuffers::Vector<uint32_t>> cluster_spectrum) {
    fbb_.AddOffset(GEMHist::VT_CLUSTER_SPECTRUM, cluster_spectrum);
  }
  void add_bin_width(uint32_t bin_width) {
    fbb_.AddElement<uint32_t>(GEMHist::VT_BIN_WIDTH, bin_width, 0);
  }
  GEMHistBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GEMHistBuilder &operator=(const GEMHistBuilder &);
  flatbuffers::Offset<GEMHist> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<GEMHist>(end);
    return o;
  }
};

inline flatbuffers::Offset<GEMHist> CreateGEMHist(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> xstrips = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> ystrips = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> xspectrum = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> yspectrum = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> cluster_spectrum = 0,
    uint32_t bin_width = 0) {
  GEMHistBuilder builder_(_fbb);
  builder_.add_bin_width(bin_width);
  builder_.add_cluster_spectrum(cluster_spectrum);
  builder_.add_yspectrum(yspectrum);
  builder_.add_xspectrum(xspectrum);
  builder_.add_ystrips(ystrips);
  builder_.add_xstrips(xstrips);
  return builder_.Finish();
}

inline flatbuffers::Offset<GEMHist>
CreateGEMHistDirect(flatbuffers::FlatBufferBuilder &_fbb,
                    const std::vector<uint32_t> *xstrips = nullptr,
                    const std::vector<uint32_t> *ystrips = nullptr,
                    const std::vector<uint32_t> *xspectrum = nullptr,
                    const std::vector<uint32_t> *yspectrum = nullptr,
                    const std::vector<uint32_t> *cluster_spectrum = nullptr,
                    uint32_t bin_width = 0) {
  return CreateGEMHist(
      _fbb, xstrips ? _fbb.CreateVector<uint32_t>(*xstrips) : 0,
      ystrips ? _fbb.CreateVector<uint32_t>(*ystrips) : 0,
      xspectrum ? _fbb.CreateVector<uint32_t>(*xspectrum) : 0,
      yspectrum ? _fbb.CreateVector<uint32_t>(*yspectrum) : 0,
      cluster_spectrum ? _fbb.CreateVector<uint32_t>(*cluster_spectrum) : 0,
      bin_width);
}

struct MonitorMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MonitorMessage";
  }
  enum { VT_SOURCE_NAME = 4, VT_DATA_TYPE = 6, VT_DATA = 8 };
  const flatbuffers::String *source_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE_NAME);
  }
  flatbuffers::String *mutable_source_name() {
    return GetPointer<flatbuffers::String *>(VT_SOURCE_NAME);
  }
  DataField data_type() const {
    return static_cast<DataField>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  bool mutate_data_type(DataField _data_type) {
    return SetField(VT_DATA_TYPE, static_cast<uint8_t>(_data_type));
  }
  const void *data() const { return GetPointer<const void *>(VT_DATA); }
  void *mutable_data() { return GetPointer<void *>(VT_DATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SOURCE_NAME) &&
           verifier.Verify(source_name()) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           VerifyDataField(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct MonitorMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source_name(flatbuffers::Offset<flatbuffers::String> source_name) {
    fbb_.AddOffset(MonitorMessage::VT_SOURCE_NAME, source_name);
  }
  void add_data_type(DataField data_type) {
    fbb_.AddElement<uint8_t>(MonitorMessage::VT_DATA_TYPE,
                             static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(MonitorMessage::VT_DATA, data);
  }
  MonitorMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MonitorMessageBuilder &operator=(const MonitorMessageBuilder &);
  flatbuffers::Offset<MonitorMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<MonitorMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<MonitorMessage>
CreateMonitorMessage(flatbuffers::FlatBufferBuilder &_fbb,
                     flatbuffers::Offset<flatbuffers::String> source_name = 0,
                     DataField data_type = DataField::NONE,
                     flatbuffers::Offset<void> data = 0) {
  MonitorMessageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_source_name(source_name);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MonitorMessage> CreateMonitorMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb, const char *source_name = nullptr,
    DataField data_type = DataField::NONE, flatbuffers::Offset<void> data = 0) {
  return CreateMonitorMessage(
      _fbb, source_name ? _fbb.CreateString(source_name) : 0, data_type, data);
}

inline bool VerifyDataField(flatbuffers::Verifier &verifier, const void *obj,
                            DataField type) {
  switch (type) {
  case DataField::NONE: {
    return true;
  }
  case DataField::GEMHist: {
    auto ptr = reinterpret_cast<const GEMHist *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case DataField::GEMTrack: {
    auto ptr = reinterpret_cast<const GEMTrack *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case DataField::MONHit: {
    auto ptr = reinterpret_cast<const MONHit *>(obj);
    return verifier.VerifyTable(ptr);
  }
  default:
    return false;
  }
}

inline bool VerifyDataFieldVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size())
    return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDataField(verifier, values->Get(i),
                         types->GetEnum<DataField>(i))) {
      return false;
    }
  }
  return true;
}

inline const MonitorMessage *GetMonitorMessage(const void *buf) {
  return flatbuffers::GetRoot<MonitorMessage>(buf);
}

inline MonitorMessage *GetMutableMonitorMessage(void *buf) {
  return flatbuffers::GetMutableRoot<MonitorMessage>(buf);
}

inline const char *MonitorMessageIdentifier() { return "mo01"; }

inline bool MonitorMessageBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(buf, MonitorMessageIdentifier());
}

inline bool VerifyMonitorMessageBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MonitorMessage>(MonitorMessageIdentifier());
}

inline void
FinishMonitorMessageBuffer(flatbuffers::FlatBufferBuilder &fbb,
                           flatbuffers::Offset<MonitorMessage> root) {
  fbb.Finish(root, MonitorMessageIdentifier());
}

#endif // FLATBUFFERS_GENERATED_MO01NMX_H_
