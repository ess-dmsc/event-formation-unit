// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MONEFU_H_
#define FLATBUFFERS_GENERATED_MONEFU_H_

#include "flatbuffers/flatbuffers.h"

struct pos;

struct GEMTrack;

struct GEMHist;

struct MonitorMessage;

enum DataField {
  DataField_NONE = 0,
  DataField_GEMHist = 1,
  DataField_GEMTrack = 2,
  DataField_MIN = DataField_NONE,
  DataField_MAX = DataField_GEMTrack
};

inline const char **EnumNamesDataField() {
  static const char *names[] = {
    "NONE",
    "GEMHist",
    "GEMTrack",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataField(DataField e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDataField()[index];
}

template<typename T> struct DataFieldTraits {
  static const DataField enum_value = DataField_NONE;
};

template<> struct DataFieldTraits<GEMHist> {
  static const DataField enum_value = DataField_GEMHist;
};

template<> struct DataFieldTraits<GEMTrack> {
  static const DataField enum_value = DataField_GEMTrack;
};

bool VerifyDataField(flatbuffers::Verifier &verifier, const void *obj, DataField type);
bool VerifyDataFieldVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct pos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STRIP = 4,
    VT_TIME = 6,
    VT_ADC = 8
  };
  uint32_t strip() const {
    return GetField<uint32_t>(VT_STRIP, 0);
  }
  uint32_t time() const {
    return GetField<uint32_t>(VT_TIME, 0);
  }
  uint32_t adc() const {
    return GetField<uint32_t>(VT_ADC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STRIP) &&
           VerifyField<uint32_t>(verifier, VT_TIME) &&
           VerifyField<uint32_t>(verifier, VT_ADC) &&
           verifier.EndTable();
  }
};

struct posBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_strip(uint32_t strip) {
    fbb_.AddElement<uint32_t>(pos::VT_STRIP, strip, 0);
  }
  void add_time(uint32_t time) {
    fbb_.AddElement<uint32_t>(pos::VT_TIME, time, 0);
  }
  void add_adc(uint32_t adc) {
    fbb_.AddElement<uint32_t>(pos::VT_ADC, adc, 0);
  }
  posBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  posBuilder &operator=(const posBuilder &);
  flatbuffers::Offset<pos> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<pos>(end);
    return o;
  }
};

inline flatbuffers::Offset<pos> Createpos(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t strip = 0,
    uint32_t time = 0,
    uint32_t adc = 0) {
  posBuilder builder_(_fbb);
  builder_.add_adc(adc);
  builder_.add_time(time);
  builder_.add_strip(strip);
  return builder_.Finish();
}

struct GEMTrack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_XTRACK = 4,
    VT_YTRACK = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<pos>> *xtrack() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pos>> *>(VT_XTRACK);
  }
  const flatbuffers::Vector<flatbuffers::Offset<pos>> *ytrack() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<pos>> *>(VT_YTRACK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_XTRACK) &&
           verifier.Verify(xtrack()) &&
           verifier.VerifyVectorOfTables(xtrack()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_YTRACK) &&
           verifier.Verify(ytrack()) &&
           verifier.VerifyVectorOfTables(ytrack()) &&
           verifier.EndTable();
  }
};

struct GEMTrackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_xtrack(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pos>>> xtrack) {
    fbb_.AddOffset(GEMTrack::VT_XTRACK, xtrack);
  }
  void add_ytrack(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pos>>> ytrack) {
    fbb_.AddOffset(GEMTrack::VT_YTRACK, ytrack);
  }
  GEMTrackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GEMTrackBuilder &operator=(const GEMTrackBuilder &);
  flatbuffers::Offset<GEMTrack> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<GEMTrack>(end);
    return o;
  }
};

inline flatbuffers::Offset<GEMTrack> CreateGEMTrack(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pos>>> xtrack = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<pos>>> ytrack = 0) {
  GEMTrackBuilder builder_(_fbb);
  builder_.add_ytrack(ytrack);
  builder_.add_xtrack(xtrack);
  return builder_.Finish();
}

inline flatbuffers::Offset<GEMTrack> CreateGEMTrackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<pos>> *xtrack = nullptr,
    const std::vector<flatbuffers::Offset<pos>> *ytrack = nullptr) {
  return CreateGEMTrack(
      _fbb,
      xtrack ? _fbb.CreateVector<flatbuffers::Offset<pos>>(*xtrack) : 0,
      ytrack ? _fbb.CreateVector<flatbuffers::Offset<pos>>(*ytrack) : 0);
}

struct GEMHist FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_XHIST = 4,
    VT_YHIST = 6
  };
  const flatbuffers::Vector<uint32_t> *xhist() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_XHIST);
  }
  const flatbuffers::Vector<uint32_t> *yhist() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_YHIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_XHIST) &&
           verifier.Verify(xhist()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_YHIST) &&
           verifier.Verify(yhist()) &&
           verifier.EndTable();
  }
};

struct GEMHistBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_xhist(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> xhist) {
    fbb_.AddOffset(GEMHist::VT_XHIST, xhist);
  }
  void add_yhist(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> yhist) {
    fbb_.AddOffset(GEMHist::VT_YHIST, yhist);
  }
  GEMHistBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GEMHistBuilder &operator=(const GEMHistBuilder &);
  flatbuffers::Offset<GEMHist> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<GEMHist>(end);
    return o;
  }
};

inline flatbuffers::Offset<GEMHist> CreateGEMHist(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> xhist = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> yhist = 0) {
  GEMHistBuilder builder_(_fbb);
  builder_.add_yhist(yhist);
  builder_.add_xhist(xhist);
  return builder_.Finish();
}

inline flatbuffers::Offset<GEMHist> CreateGEMHistDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *xhist = nullptr,
    const std::vector<uint32_t> *yhist = nullptr) {
  return CreateGEMHist(
      _fbb,
      xhist ? _fbb.CreateVector<uint32_t>(*xhist) : 0,
      yhist ? _fbb.CreateVector<uint32_t>(*yhist) : 0);
}

struct MonitorMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOURCE_NAME = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  const flatbuffers::String *source_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE_NAME);
  }
  DataField data_type() const {
    return static_cast<DataField>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SOURCE_NAME) &&
           verifier.Verify(source_name()) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           VerifyDataField(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct MonitorMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source_name(flatbuffers::Offset<flatbuffers::String> source_name) {
    fbb_.AddOffset(MonitorMessage::VT_SOURCE_NAME, source_name);
  }
  void add_data_type(DataField data_type) {
    fbb_.AddElement<uint8_t>(MonitorMessage::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(MonitorMessage::VT_DATA, data);
  }
  MonitorMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MonitorMessageBuilder &operator=(const MonitorMessageBuilder &);
  flatbuffers::Offset<MonitorMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<MonitorMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<MonitorMessage> CreateMonitorMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> source_name = 0,
    DataField data_type = DataField_NONE,
    flatbuffers::Offset<void> data = 0) {
  MonitorMessageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_source_name(source_name);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MonitorMessage> CreateMonitorMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *source_name = nullptr,
    DataField data_type = DataField_NONE,
    flatbuffers::Offset<void> data = 0) {
  return CreateMonitorMessage(
      _fbb,
      source_name ? _fbb.CreateString(source_name) : 0,
      data_type,
      data);
}

inline bool VerifyDataField(flatbuffers::Verifier &verifier, const void *obj, DataField type) {
  switch (type) {
    case DataField_NONE: {
      return true;
    }
    case DataField_GEMHist: {
      auto ptr = reinterpret_cast<const GEMHist *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataField_GEMTrack: {
      auto ptr = reinterpret_cast<const GEMTrack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyDataFieldVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDataField(
        verifier,  values->Get(i), types->GetEnum<DataField>(i))) {
      return false;
    }
  }
  return true;
}

inline const MonitorMessage *GetMonitorMessage(const void *buf) {
  return flatbuffers::GetRoot<MonitorMessage>(buf);
}

inline const char *MonitorMessageIdentifier() {
  return "moXX";
}

inline bool MonitorMessageBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MonitorMessageIdentifier());
}

inline bool VerifyMonitorMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MonitorMessage>(MonitorMessageIdentifier());
}

inline void FinishMonitorMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MonitorMessage> root) {
  fbb.Finish(root, MonitorMessageIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MONEFU_H_
