// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MONEFU_H_
#define FLATBUFFERS_GENERATED_MONEFU_H_

#include "flatbuffers/flatbuffers.h"

struct GEMHist;

struct MonitorMessage;

enum DataField {
  DataField_NONE = 0,
  DataField_GEMHist = 1,
  DataField_MIN = DataField_NONE,
  DataField_MAX = DataField_GEMHist
};

inline const char **EnumNamesDataField() {
  static const char *names[] = {
    "NONE",
    "GEMHist",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataField(DataField e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDataField()[index];
}

template<typename T> struct DataFieldTraits {
  static const DataField enum_value = DataField_NONE;
};

template<> struct DataFieldTraits<GEMHist> {
  static const DataField enum_value = DataField_GEMHist;
};

bool VerifyDataField(flatbuffers::Verifier &verifier, const void *obj, DataField type);
bool VerifyDataFieldVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct GEMHist FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_XHIST = 4,
    VT_YHIST = 6
  };
  const flatbuffers::Vector<uint32_t> *xhist() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_XHIST);
  }
  const flatbuffers::Vector<uint32_t> *yhist() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_YHIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_XHIST) &&
           verifier.Verify(xhist()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_YHIST) &&
           verifier.Verify(yhist()) &&
           verifier.EndTable();
  }
};

struct GEMHistBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_xhist(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> xhist) {
    fbb_.AddOffset(GEMHist::VT_XHIST, xhist);
  }
  void add_yhist(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> yhist) {
    fbb_.AddOffset(GEMHist::VT_YHIST, yhist);
  }
  GEMHistBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GEMHistBuilder &operator=(const GEMHistBuilder &);
  flatbuffers::Offset<GEMHist> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<GEMHist>(end);
    return o;
  }
};

inline flatbuffers::Offset<GEMHist> CreateGEMHist(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> xhist = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> yhist = 0) {
  GEMHistBuilder builder_(_fbb);
  builder_.add_yhist(yhist);
  builder_.add_xhist(xhist);
  return builder_.Finish();
}

inline flatbuffers::Offset<GEMHist> CreateGEMHistDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *xhist = nullptr,
    const std::vector<uint32_t> *yhist = nullptr) {
  return CreateGEMHist(
      _fbb,
      xhist ? _fbb.CreateVector<uint32_t>(*xhist) : 0,
      yhist ? _fbb.CreateVector<uint32_t>(*yhist) : 0);
}

struct MonitorMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SOURCE_NAME = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  const flatbuffers::String *source_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE_NAME);
  }
  DataField data_type() const {
    return static_cast<DataField>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SOURCE_NAME) &&
           verifier.Verify(source_name()) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           VerifyDataField(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct MonitorMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source_name(flatbuffers::Offset<flatbuffers::String> source_name) {
    fbb_.AddOffset(MonitorMessage::VT_SOURCE_NAME, source_name);
  }
  void add_data_type(DataField data_type) {
    fbb_.AddElement<uint8_t>(MonitorMessage::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(MonitorMessage::VT_DATA, data);
  }
  MonitorMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MonitorMessageBuilder &operator=(const MonitorMessageBuilder &);
  flatbuffers::Offset<MonitorMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<MonitorMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<MonitorMessage> CreateMonitorMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> source_name = 0,
    DataField data_type = DataField_NONE,
    flatbuffers::Offset<void> data = 0) {
  MonitorMessageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_source_name(source_name);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MonitorMessage> CreateMonitorMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *source_name = nullptr,
    DataField data_type = DataField_NONE,
    flatbuffers::Offset<void> data = 0) {
  return CreateMonitorMessage(
      _fbb,
      source_name ? _fbb.CreateString(source_name) : 0,
      data_type,
      data);
}

inline bool VerifyDataField(flatbuffers::Verifier &verifier, const void *obj, DataField type) {
  switch (type) {
    case DataField_NONE: {
      return true;
    }
    case DataField_GEMHist: {
      auto ptr = reinterpret_cast<const GEMHist *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyDataFieldVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDataField(
        verifier,  values->Get(i), types->GetEnum<DataField>(i))) {
      return false;
    }
  }
  return true;
}

inline const MonitorMessage *GetMonitorMessage(const void *buf) {
  return flatbuffers::GetRoot<MonitorMessage>(buf);
}

inline const char *MonitorMessageIdentifier() {
  return "moXX";
}

inline bool MonitorMessageBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MonitorMessageIdentifier());
}

inline bool VerifyMonitorMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MonitorMessage>(MonitorMessageIdentifier());
}

inline void FinishMonitorMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MonitorMessage> root) {
  fbb.Finish(root, MonitorMessageIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MONEFU_H_
